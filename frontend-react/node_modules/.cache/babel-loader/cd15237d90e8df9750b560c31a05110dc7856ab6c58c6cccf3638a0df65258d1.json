{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { raf, isHTMLElement, addDomEvent, trackPointerMove, dataAttr, getEventTarget, isSelfTarget, getEventStep, getEventKey } from '@zag-js/dom-query';\nimport { clampPoint, clampSize, createRect, subtractPoints, resizeRect, addPoints, getElementRect, isPointEqual, isSizeEqual, getWindowRect, constrainRect } from '@zag-js/rect-utils';\nimport { invariant, match, pick, clampValue, ensureProps, createSplitProps, toPx } from '@zag-js/utils';\nimport { createGuards, createMachine } from '@zag-js/core';\nimport { proxy, subscribe } from '@zag-js/store';\nimport { createProps } from '@zag-js/types';\n\n// src/floating-panel.anatomy.ts\nvar anatomy = createAnatomy(\"floating-panel\").parts(\"trigger\", \"positioner\", \"content\", \"header\", \"body\", \"title\", \"resizeTrigger\", \"dragTrigger\", \"stageTrigger\", \"closeTrigger\", \"control\");\nvar parts = anatomy.build();\nvar getTriggerId = ctx => ctx.ids?.trigger ?? `float:${ctx.id}:trigger`;\nvar getPositionerId = ctx => ctx.ids?.positioner ?? `float:${ctx.id}:positioner`;\nvar getContentId = ctx => ctx.ids?.content ?? `float:${ctx.id}:content`;\nvar getTitleId = ctx => ctx.ids?.title ?? `float:${ctx.id}:title`;\nvar getHeaderId = ctx => ctx.ids?.header ?? `float:${ctx.id}:header`;\nvar getTriggerEl = ctx => ctx.getById(getTriggerId(ctx));\nvar getPositionerEl = ctx => ctx.getById(getPositionerId(ctx));\nvar getContentEl = ctx => ctx.getById(getContentId(ctx));\nvar getHeaderEl = ctx => ctx.getById(getHeaderId(ctx));\nvar getBoundaryRect = (ctx, boundaryEl, allowOverflow) => {\n  let boundaryRect;\n  if (isHTMLElement(boundaryEl)) {\n    boundaryRect = getElementRect(boundaryEl);\n  } else {\n    boundaryRect = getWindowRect(ctx.getWin());\n  }\n  if (allowOverflow) {\n    boundaryRect = createRect({\n      x: -boundaryRect.width,\n      // empty(left)\n      y: boundaryRect.minY,\n      width: boundaryRect.width * 3,\n      // empty(left) + win + empty(right)\n      height: boundaryRect.height * 2\n      // win + empty(bottom)\n    });\n  }\n  return pick(boundaryRect, [\"x\", \"y\", \"width\", \"height\"]);\n};\n\n// src/get-resize-axis-style.ts\nfunction getResizeAxisStyle(axis) {\n  switch (axis) {\n    case \"n\":\n      return {\n        cursor: \"n-resize\",\n        width: \"100%\",\n        left: \"50%\",\n        translate: \"-50%\"\n      };\n    case \"e\":\n      return {\n        cursor: \"e-resize\",\n        height: \"100%\",\n        right: 0,\n        top: \"50%\",\n        translate: \"0 -50%\"\n      };\n    case \"s\":\n      return {\n        cursor: \"s-resize\",\n        width: \"100%\",\n        bottom: 0,\n        left: \"50%\",\n        translate: \"-50%\"\n      };\n    case \"w\":\n      return {\n        cursor: \"w-resize\",\n        height: \"100%\",\n        left: 0,\n        top: \"50%\",\n        translate: \"0 -50%\"\n      };\n    case \"se\":\n      return {\n        cursor: \"se-resize\",\n        bottom: 0,\n        right: 0\n      };\n    case \"sw\":\n      return {\n        cursor: \"sw-resize\",\n        bottom: 0,\n        left: 0\n      };\n    case \"ne\":\n      return {\n        cursor: \"ne-resize\",\n        top: 0,\n        right: 0\n      };\n    case \"nw\":\n      return {\n        cursor: \"nw-resize\",\n        top: 0,\n        left: 0\n      };\n    default:\n      throw new Error(`Invalid axis: ${axis}`);\n  }\n}\nvar validStages = /* @__PURE__ */new Set([\"minimized\", \"maximized\", \"default\"]);\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    scope,\n    prop,\n    computed,\n    context\n  } = service;\n  const open = state.hasTag(\"open\");\n  const dragging = state.matches(\"open.dragging\");\n  const resizing = state.matches(\"open.resizing\");\n  const isTopmost = context.get(\"isTopmost\");\n  const size = context.get(\"size\");\n  const position = context.get(\"position\");\n  const isMaximized = computed(\"isMaximized\");\n  const isMinimized = computed(\"isMinimized\");\n  const isStaged = computed(\"isStaged\");\n  const canResize = computed(\"canResize\");\n  const canDrag = computed(\"canDrag\");\n  return {\n    open,\n    resizable: prop(\"resizable\"),\n    draggable: prop(\"draggable\"),\n    setOpen(nextOpen) {\n      const open2 = state.hasTag(\"open\");\n      if (open2 === nextOpen) return;\n      send({\n        type: nextOpen ? \"OPEN\" : \"CLOSE\"\n      });\n    },\n    dragging,\n    resizing,\n    position,\n    size,\n    setPosition(position2) {\n      send({\n        type: \"SET_POSITION\",\n        position: position2\n      });\n    },\n    setSize(size2) {\n      send({\n        type: \"SET_SIZE\",\n        size: size2\n      });\n    },\n    minimize() {\n      send({\n        type: \"MINIMIZE\"\n      });\n    },\n    maximize() {\n      send({\n        type: \"MAXIMIZE\"\n      });\n    },\n    restore() {\n      send({\n        type: \"RESTORE\"\n      });\n    },\n    getTriggerProps() {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        type: \"button\",\n        disabled: prop(\"disabled\"),\n        id: getTriggerId(scope),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-dragging\": dataAttr(dragging),\n        \"aria-controls\": getContentId(scope),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (prop(\"disabled\")) return;\n          const open2 = state.hasTag(\"open\");\n          send({\n            type: open2 ? \"CLOSE\" : \"OPEN\",\n            src: \"trigger\"\n          });\n        }\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        ...parts.positioner.attrs,\n        id: getPositionerId(scope),\n        style: {\n          \"--width\": toPx(size?.width),\n          \"--height\": toPx(size?.height),\n          \"--x\": toPx(position?.x),\n          \"--y\": toPx(position?.y),\n          position: prop(\"strategy\"),\n          top: \"var(--y)\",\n          left: \"var(--x)\"\n        }\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        role: \"dialog\",\n        tabIndex: 0,\n        hidden: !open,\n        id: getContentId(scope),\n        \"aria-labelledby\": getTitleId(scope),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-dragging\": dataAttr(dragging),\n        \"data-topmost\": dataAttr(isTopmost),\n        \"data-behind\": dataAttr(!isTopmost),\n        style: {\n          width: \"var(--width)\",\n          height: \"var(--height)\",\n          overflow: isMinimized ? \"hidden\" : void 0\n        },\n        onFocus() {\n          send({\n            type: \"CONTENT_FOCUS\"\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!isSelfTarget(event)) return;\n          const step = getEventStep(event) * prop(\"gridSize\");\n          const keyMap = {\n            Escape() {\n              if (!isTopmost) return;\n              send({\n                type: \"ESCAPE\"\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"MOVE\",\n                direction: \"left\",\n                step\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"MOVE\",\n                direction: \"right\",\n                step\n              });\n            },\n            ArrowUp() {\n              send({\n                type: \"MOVE\",\n                direction: \"up\",\n                step\n              });\n            },\n            ArrowDown() {\n              send({\n                type: \"MOVE\",\n                direction: \"down\",\n                step\n              });\n            }\n          };\n          const handler = keyMap[getEventKey(event, {\n            dir: prop(\"dir\")\n          })];\n          if (handler) {\n            event.preventDefault();\n            handler(event);\n          }\n        }\n      });\n    },\n    getCloseTriggerProps() {\n      return normalize.button({\n        ...parts.closeTrigger.attrs,\n        disabled: prop(\"disabled\"),\n        \"aria-label\": \"Close Window\",\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"CLOSE\"\n          });\n        }\n      });\n    },\n    getStageTriggerProps(props2) {\n      if (!validStages.has(props2.stage)) {\n        throw new Error(`[zag-js] Invalid stage: ${props2.stage}. Must be one of: ${Array.from(validStages).join(\", \")}`);\n      }\n      const translations = prop(\"translations\");\n      const actionProps = match(props2.stage, {\n        minimized: () => ({\n          \"aria-label\": translations.minimize,\n          hidden: isStaged\n        }),\n        maximized: () => ({\n          \"aria-label\": translations.maximize,\n          hidden: isStaged\n        }),\n        default: () => ({\n          \"aria-label\": translations.restore,\n          hidden: !isStaged\n        })\n      });\n      return normalize.button({\n        ...parts.stageTrigger.attrs,\n        disabled: prop(\"disabled\"),\n        ...actionProps,\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          const type = match(props2.stage, {\n            minimized: () => \"MINIMIZE\",\n            maximized: () => \"MAXIMIZE\",\n            default: () => \"RESTORE\"\n          });\n          send({\n            type: type.toUpperCase()\n          });\n        }\n      });\n    },\n    getResizeTriggerProps(props2) {\n      return normalize.element({\n        ...parts.resizeTrigger.attrs,\n        \"data-disabled\": dataAttr(!canResize),\n        \"data-axis\": props2.axis,\n        onPointerDown(event) {\n          if (!canResize || event.button == 2) return;\n          event.currentTarget.setPointerCapture(event.pointerId);\n          event.stopPropagation();\n          send({\n            type: \"RESIZE_START\",\n            axis: props2.axis,\n            position: {\n              x: event.clientX,\n              y: event.clientY\n            }\n          });\n        },\n        onPointerUp(event) {\n          if (!canResize) return;\n          const node = event.currentTarget;\n          if (node.hasPointerCapture(event.pointerId)) {\n            node.releasePointerCapture(event.pointerId);\n          }\n        },\n        style: {\n          position: \"absolute\",\n          touchAction: \"none\",\n          ...getResizeAxisStyle(props2.axis)\n        }\n      });\n    },\n    getDragTriggerProps() {\n      return normalize.element({\n        ...parts.dragTrigger.attrs,\n        \"data-disabled\": dataAttr(!canDrag),\n        onPointerDown(event) {\n          if (!canDrag || event.button == 2) return;\n          const target = getEventTarget(event);\n          if (target?.closest(\"button\") || target?.closest(\"[data-no-drag]\")) {\n            return;\n          }\n          event.currentTarget.setPointerCapture(event.pointerId);\n          event.stopPropagation();\n          send({\n            type: \"DRAG_START\",\n            pointerId: event.pointerId,\n            position: {\n              x: event.clientX,\n              y: event.clientY\n            }\n          });\n        },\n        onPointerUp(event) {\n          if (!canDrag) return;\n          const node = event.currentTarget;\n          if (node.hasPointerCapture(event.pointerId)) {\n            node.releasePointerCapture(event.pointerId);\n          }\n        },\n        onDoubleClick() {\n          send({\n            type: isMaximized ? \"RESTORE\" : \"MAXIMIZE\"\n          });\n        },\n        style: {\n          WebkitUserSelect: \"none\",\n          userSelect: \"none\",\n          touchAction: \"none\",\n          cursor: \"move\"\n        }\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        \"data-disabled\": dataAttr(prop(\"disabled\")),\n        \"data-stage\": context.get(\"stage\")\n      });\n    },\n    getTitleProps() {\n      return normalize.element({\n        ...parts.title.attrs,\n        id: getTitleId(scope)\n      });\n    },\n    getHeaderProps() {\n      return normalize.element({\n        ...parts.header.attrs,\n        id: getHeaderId(scope),\n        \"data-dragging\": dataAttr(dragging),\n        \"data-topmost\": dataAttr(isTopmost),\n        \"data-behind\": dataAttr(!isTopmost)\n      });\n    },\n    getBodyProps() {\n      return normalize.element({\n        ...parts.body.attrs,\n        \"data-dragging\": dataAttr(dragging),\n        hidden: isMinimized\n      });\n    }\n  };\n}\nvar panelStack = proxy({\n  stack: [],\n  count() {\n    return this.stack.length;\n  },\n  add(panelId) {\n    if (this.stack.includes(panelId)) return;\n    this.stack.push(panelId);\n  },\n  remove(panelId) {\n    const index = this.stack.indexOf(panelId);\n    if (index < 0) return;\n    this.stack.splice(index, 1);\n  },\n  bringToFront(id) {\n    this.remove(id);\n    this.add(id);\n  },\n  isTopmost(id) {\n    return this.stack[this.stack.length - 1] === id;\n  },\n  indexOf(id) {\n    return this.stack.indexOf(id);\n  }\n});\n\n// src/floating-panel.machine.ts\nvar {\n  not,\n  and\n} = createGuards();\nvar defaultTranslations = {\n  minimize: \"Minimize window\",\n  maximize: \"Maximize window\",\n  restore: \"Restore window\"\n};\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    ensureProps(props2, [\"id\"], \"floating-panel\");\n    return {\n      strategy: \"fixed\",\n      gridSize: 1,\n      defaultSize: {\n        width: 320,\n        height: 240\n      },\n      defaultPosition: {\n        x: 300,\n        y: 100\n      },\n      allowOverflow: true,\n      resizable: true,\n      draggable: true,\n      ...props2,\n      hasSpecifiedPosition: !!props2.defaultPosition || !!props2.position,\n      translations: {\n        ...defaultTranslations,\n        ...props2.translations\n      }\n    };\n  },\n  initialState({\n    prop\n  }) {\n    const open = prop(\"open\") || prop(\"defaultOpen\");\n    return open ? \"open\" : \"closed\";\n  },\n  context({\n    prop,\n    bindable\n  }) {\n    return {\n      size: bindable(() => ({\n        defaultValue: prop(\"defaultSize\"),\n        value: prop(\"size\"),\n        isEqual: isSizeEqual,\n        sync: true,\n        hash(v) {\n          return `W:${v.width} H:${v.height}`;\n        },\n        onChange(value) {\n          prop(\"onSizeChange\")?.({\n            size: value\n          });\n        }\n      })),\n      position: bindable(() => ({\n        defaultValue: prop(\"defaultPosition\"),\n        value: prop(\"position\"),\n        isEqual: isPointEqual,\n        sync: true,\n        hash(v) {\n          return `X:${v.x} Y:${v.y}`;\n        },\n        onChange(value) {\n          prop(\"onPositionChange\")?.({\n            position: value\n          });\n        }\n      })),\n      stage: bindable(() => ({\n        defaultValue: \"default\",\n        onChange(value) {\n          prop(\"onStageChange\")?.({\n            stage: value\n          });\n        }\n      })),\n      lastEventPosition: bindable(() => ({\n        defaultValue: null\n      })),\n      prevPosition: bindable(() => ({\n        defaultValue: null\n      })),\n      prevSize: bindable(() => ({\n        defaultValue: null\n      })),\n      isTopmost: bindable(() => ({\n        defaultValue: void 0\n      }))\n    };\n  },\n  computed: {\n    isMaximized: ({\n      context\n    }) => context.get(\"stage\") === \"maximized\",\n    isMinimized: ({\n      context\n    }) => context.get(\"stage\") === \"minimized\",\n    isStaged: ({\n      context\n    }) => context.get(\"stage\") !== \"default\",\n    canResize: ({\n      context,\n      prop\n    }) => (prop(\"resizable\") || !prop(\"disabled\")) && context.get(\"stage\") === \"default\",\n    canDrag: ({\n      prop,\n      computed\n    }) => (prop(\"draggable\") || !prop(\"disabled\")) && !computed(\"isMaximized\")\n  },\n  watch({\n    track,\n    context,\n    action,\n    prop\n  }) {\n    track([() => context.hash(\"position\")], () => {\n      action([\"setPositionStyle\"]);\n    });\n    track([() => context.hash(\"size\")], () => {\n      action([\"setSizeStyle\"]);\n    });\n    track([() => prop(\"open\")], () => {\n      action([\"toggleVisibility\"]);\n    });\n  },\n  effects: [\"trackPanelStack\"],\n  on: {\n    CONTENT_FOCUS: {\n      actions: [\"bringToFrontOfPanelStack\"]\n    },\n    SET_POSITION: {\n      actions: [\"setPosition\"]\n    },\n    SET_SIZE: {\n      actions: [\"setSize\"]\n    }\n  },\n  states: {\n    closed: {\n      tags: [\"closed\"],\n      on: {\n        \"CONTROLLED.OPEN\": {\n          target: \"open\",\n          actions: [\"setAnchorPosition\", \"setPositionStyle\", \"setSizeStyle\", \"focusContentEl\"]\n        },\n        OPEN: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"invokeOnOpen\", \"setAnchorPosition\", \"setPositionStyle\", \"setSizeStyle\", \"focusContentEl\"]\n        }]\n      }\n    },\n    open: {\n      tags: [\"open\"],\n      entry: [\"bringToFrontOfPanelStack\"],\n      effects: [\"trackBoundaryRect\"],\n      on: {\n        DRAG_START: {\n          guard: not(\"isMaximized\"),\n          target: \"open.dragging\",\n          actions: [\"setPrevPosition\"]\n        },\n        RESIZE_START: {\n          guard: not(\"isMinimized\"),\n          target: \"open.resizing\",\n          actions: [\"setPrevSize\"]\n        },\n        \"CONTROLLED.CLOSE\": {\n          target: \"closed\",\n          actions: [\"resetRect\", \"focusTriggerEl\"]\n        },\n        CLOSE: [{\n          guard: \"isOpenControlled\",\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"closed\",\n          actions: [\"invokeOnClose\", \"resetRect\", \"focusTriggerEl\"]\n        }],\n        ESCAPE: [{\n          guard: and(\"isOpenControlled\", \"closeOnEsc\"),\n          actions: [\"invokeOnClose\"]\n        }, {\n          guard: \"closeOnEsc\",\n          target: \"closed\",\n          actions: [\"invokeOnClose\", \"resetRect\", \"focusTriggerEl\"]\n        }],\n        MINIMIZE: {\n          actions: [\"setMinimized\"]\n        },\n        MAXIMIZE: {\n          actions: [\"setMaximized\"]\n        },\n        RESTORE: {\n          actions: [\"setRestored\"]\n        },\n        MOVE: {\n          actions: [\"setPositionFromKeyboard\"]\n        }\n      }\n    },\n    \"open.dragging\": {\n      tags: [\"open\"],\n      effects: [\"trackPointerMove\"],\n      exit: [\"clearPrevPosition\"],\n      on: {\n        DRAG: {\n          actions: [\"setPosition\"]\n        },\n        DRAG_END: {\n          target: \"open\",\n          actions: [\"invokeOnDragEnd\"]\n        },\n        \"CONTROLLED.CLOSE\": {\n          target: \"closed\",\n          actions: [\"resetRect\"]\n        },\n        CLOSE: [{\n          guard: \"isOpenControlled\",\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"closed\",\n          actions: [\"invokeOnClose\", \"resetRect\"]\n        }],\n        ESCAPE: {\n          target: \"open\"\n        }\n      }\n    },\n    \"open.resizing\": {\n      tags: [\"open\"],\n      effects: [\"trackPointerMove\"],\n      exit: [\"clearPrevSize\"],\n      on: {\n        DRAG: {\n          actions: [\"setSize\"]\n        },\n        DRAG_END: {\n          target: \"open\",\n          actions: [\"invokeOnResizeEnd\"]\n        },\n        \"CONTROLLED.CLOSE\": {\n          target: \"closed\",\n          actions: [\"resetRect\"]\n        },\n        CLOSE: [{\n          guard: \"isOpenControlled\",\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"closed\",\n          actions: [\"invokeOnClose\", \"resetRect\"]\n        }],\n        ESCAPE: {\n          target: \"open\"\n        }\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      closeOnEsc: ({\n        prop\n      }) => !!prop(\"closeOnEscape\"),\n      isMaximized: ({\n        context\n      }) => context.get(\"stage\") === \"maximized\",\n      isMinimized: ({\n        context\n      }) => context.get(\"stage\") === \"minimized\",\n      isOpenControlled: ({\n        prop\n      }) => prop(\"open\") != void 0\n    },\n    effects: {\n      trackPointerMove({\n        scope,\n        send,\n        event: evt,\n        prop\n      }) {\n        const doc = scope.getDoc();\n        const boundaryEl = prop(\"getBoundaryEl\")?.();\n        const boundaryRect = getBoundaryRect(scope, boundaryEl, false);\n        return trackPointerMove(doc, {\n          onPointerMove({\n            point,\n            event\n          }) {\n            const {\n              altKey,\n              shiftKey\n            } = event;\n            let x = clampValue(point.x, boundaryRect.x, boundaryRect.x + boundaryRect.width);\n            let y = clampValue(point.y, boundaryRect.y, boundaryRect.y + boundaryRect.height);\n            send({\n              type: \"DRAG\",\n              position: {\n                x,\n                y\n              },\n              axis: evt.axis,\n              altKey,\n              shiftKey\n            });\n          },\n          onPointerUp() {\n            send({\n              type: \"DRAG_END\"\n            });\n          }\n        });\n      },\n      trackBoundaryRect({\n        context,\n        scope,\n        prop,\n        computed\n      }) {\n        const win = scope.getWin();\n        let skip = true;\n        const exec = () => {\n          if (skip) {\n            skip = false;\n            return;\n          }\n          const boundaryEl2 = prop(\"getBoundaryEl\")?.();\n          let boundaryRect = getBoundaryRect(scope, boundaryEl2, false);\n          if (!computed(\"isMaximized\")) {\n            const rect = {\n              ...context.get(\"position\"),\n              ...context.get(\"size\")\n            };\n            boundaryRect = constrainRect(rect, boundaryRect);\n          }\n          context.set(\"size\", pick(boundaryRect, [\"width\", \"height\"]));\n          context.set(\"position\", pick(boundaryRect, [\"x\", \"y\"]));\n        };\n        const boundaryEl = prop(\"getBoundaryEl\")?.();\n        if (isHTMLElement(boundaryEl)) {\n          const obs = new win.ResizeObserver(exec);\n          obs.observe(boundaryEl);\n          return () => obs.disconnect();\n        }\n        return addDomEvent(win, \"resize\", exec);\n      },\n      trackPanelStack({\n        context,\n        scope\n      }) {\n        const unsub = subscribe(panelStack, () => {\n          context.set(\"isTopmost\", panelStack.isTopmost(scope.id));\n          const contentEl = getContentEl(scope);\n          if (!contentEl) return;\n          const index = panelStack.indexOf(scope.id);\n          if (index === -1) return;\n          contentEl.style.setProperty(\"--z-index\", `${index + 1}`);\n        });\n        return () => {\n          panelStack.remove(scope.id);\n          unsub();\n        };\n      }\n    },\n    actions: {\n      setAnchorPosition({\n        context,\n        prop,\n        scope\n      }) {\n        if (prop(\"hasSpecifiedPosition\")) return;\n        const hasPrevRect = context.get(\"prevPosition\") || context.get(\"prevSize\");\n        if (prop(\"persistRect\") && hasPrevRect) return;\n        raf(() => {\n          const triggerRect = getTriggerEl(scope);\n          const boundaryRect = getBoundaryRect(scope, prop(\"getBoundaryEl\")?.(), false);\n          let anchorPosition = prop(\"getAnchorPosition\")?.({\n            triggerRect: triggerRect ? DOMRect.fromRect(getElementRect(triggerRect)) : null,\n            boundaryRect: DOMRect.fromRect(boundaryRect)\n          });\n          if (!anchorPosition) {\n            const size = context.get(\"size\");\n            anchorPosition = {\n              x: boundaryRect.x + (boundaryRect.width - size.width) / 2,\n              y: boundaryRect.y + (boundaryRect.height - size.height) / 2\n            };\n          }\n          if (!anchorPosition) return;\n          context.set(\"position\", anchorPosition);\n        });\n      },\n      setPrevPosition({\n        context,\n        event\n      }) {\n        context.set(\"prevPosition\", {\n          ...context.get(\"position\")\n        });\n        context.set(\"lastEventPosition\", event.position);\n      },\n      clearPrevPosition({\n        context,\n        prop\n      }) {\n        if (!prop(\"persistRect\")) context.set(\"prevPosition\", null);\n        context.set(\"lastEventPosition\", null);\n      },\n      setPosition({\n        context,\n        event,\n        prop,\n        scope\n      }) {\n        let diff = subtractPoints(event.position, context.get(\"lastEventPosition\"));\n        diff.x = Math.round(diff.x / prop(\"gridSize\")) * prop(\"gridSize\");\n        diff.y = Math.round(diff.y / prop(\"gridSize\")) * prop(\"gridSize\");\n        const prevPosition = context.get(\"prevPosition\");\n        if (!prevPosition) return;\n        let position = addPoints(prevPosition, diff);\n        const boundaryEl = prop(\"getBoundaryEl\")?.();\n        const boundaryRect = getBoundaryRect(scope, boundaryEl, prop(\"allowOverflow\"));\n        position = clampPoint(position, context.get(\"size\"), boundaryRect);\n        context.set(\"position\", position);\n      },\n      setPositionStyle({\n        scope,\n        context\n      }) {\n        const el = getPositionerEl(scope);\n        const position = context.get(\"position\");\n        el?.style.setProperty(\"--x\", `${position.x}px`);\n        el?.style.setProperty(\"--y\", `${position.y}px`);\n      },\n      resetRect({\n        context,\n        prop\n      }) {\n        context.set(\"stage\", \"default\");\n        if (!prop(\"persistRect\")) {\n          context.set(\"position\", context.initial(\"position\"));\n          context.set(\"size\", context.initial(\"size\"));\n        }\n      },\n      setPrevSize({\n        context,\n        event\n      }) {\n        context.set(\"prevSize\", {\n          ...context.get(\"size\")\n        });\n        context.set(\"prevPosition\", {\n          ...context.get(\"position\")\n        });\n        context.set(\"lastEventPosition\", event.position);\n      },\n      clearPrevSize({\n        context\n      }) {\n        context.set(\"prevSize\", null);\n        context.set(\"prevPosition\", null);\n        context.set(\"lastEventPosition\", null);\n      },\n      setSize({\n        context,\n        event,\n        scope,\n        prop\n      }) {\n        const prevSize = context.get(\"prevSize\");\n        const prevPosition = context.get(\"prevPosition\");\n        const lastEventPosition = context.get(\"lastEventPosition\");\n        if (!prevSize || !prevPosition || !lastEventPosition) return;\n        const prevRect = createRect({\n          ...prevPosition,\n          ...prevSize\n        });\n        const offset = subtractPoints(event.position, lastEventPosition);\n        const nextRect = resizeRect(prevRect, offset, event.axis, {\n          scalingOriginMode: event.altKey ? \"center\" : \"extent\",\n          lockAspectRatio: !!prop(\"lockAspectRatio\") || event.shiftKey\n        });\n        let nextSize = pick(nextRect, [\"width\", \"height\"]);\n        let nextPosition = pick(nextRect, [\"x\", \"y\"]);\n        const boundaryEl = prop(\"getBoundaryEl\")?.();\n        const boundaryRect = getBoundaryRect(scope, boundaryEl, false);\n        nextSize = clampSize(nextSize, prop(\"minSize\"), prop(\"maxSize\"));\n        nextSize = clampSize(nextSize, prop(\"minSize\"), boundaryRect);\n        context.set(\"size\", nextSize);\n        if (nextPosition) {\n          const point = clampPoint(nextPosition, nextSize, boundaryRect);\n          context.set(\"position\", point);\n        }\n      },\n      setSizeStyle({\n        scope,\n        context\n      }) {\n        queueMicrotask(() => {\n          const el = getPositionerEl(scope);\n          const size = context.get(\"size\");\n          el?.style.setProperty(\"--width\", `${size.width}px`);\n          el?.style.setProperty(\"--height\", `${size.height}px`);\n        });\n      },\n      setMaximized({\n        context,\n        prop,\n        scope\n      }) {\n        context.set(\"stage\", \"maximized\");\n        context.set(\"prevSize\", context.get(\"size\"));\n        context.set(\"prevPosition\", context.get(\"position\"));\n        const boundaryEl = prop(\"getBoundaryEl\")?.();\n        const boundaryRect = getBoundaryRect(scope, boundaryEl, false);\n        context.set(\"position\", pick(boundaryRect, [\"x\", \"y\"]));\n        context.set(\"size\", pick(boundaryRect, [\"height\", \"width\"]));\n      },\n      setMinimized({\n        context,\n        scope\n      }) {\n        context.set(\"stage\", \"minimized\");\n        context.set(\"prevSize\", context.get(\"size\"));\n        context.set(\"prevPosition\", context.get(\"position\"));\n        const headerEl = getHeaderEl(scope);\n        if (!headerEl) return;\n        const size = {\n          ...context.get(\"size\"),\n          height: headerEl?.offsetHeight\n        };\n        context.set(\"size\", size);\n      },\n      setRestored({\n        context,\n        prop,\n        scope\n      }) {\n        const boundaryRect = getBoundaryRect(scope, prop(\"getBoundaryEl\")?.(), false);\n        context.set(\"stage\", \"default\");\n        const prevSize = context.get(\"prevSize\");\n        if (prevSize) {\n          let nextSize = prevSize;\n          nextSize = clampSize(nextSize, prop(\"minSize\"), prop(\"maxSize\"));\n          nextSize = clampSize(nextSize, prop(\"minSize\"), boundaryRect);\n          context.set(\"size\", nextSize);\n          context.set(\"prevSize\", null);\n        }\n        if (context.get(\"prevPosition\")) {\n          let nextPosition = context.get(\"prevPosition\");\n          nextPosition = clampPoint(nextPosition, context.get(\"size\"), boundaryRect);\n          context.set(\"position\", nextPosition);\n          context.set(\"prevPosition\", null);\n        }\n      },\n      setPositionFromKeyboard({\n        context,\n        event,\n        prop,\n        scope\n      }) {\n        invariant(event.step == null, \"step is required\");\n        const position = context.get(\"position\");\n        const step = event.step;\n        let nextPosition = match(event.direction, {\n          left: {\n            x: position.x - step,\n            y: position.y\n          },\n          right: {\n            x: position.x + step,\n            y: position.y\n          },\n          up: {\n            x: position.x,\n            y: position.y - step\n          },\n          down: {\n            x: position.x,\n            y: position.y + step\n          }\n        });\n        const boundaryEl = prop(\"getBoundaryEl\")?.();\n        const boundaryRect = getBoundaryRect(scope, boundaryEl, false);\n        nextPosition = clampPoint(nextPosition, context.get(\"size\"), boundaryRect);\n        context.set(\"position\", nextPosition);\n      },\n      bringToFrontOfPanelStack({\n        prop\n      }) {\n        panelStack.bringToFront(prop(\"id\"));\n      },\n      invokeOnOpen({\n        prop\n      }) {\n        prop(\"onOpenChange\")?.({\n          open: true\n        });\n      },\n      invokeOnClose({\n        prop\n      }) {\n        prop(\"onOpenChange\")?.({\n          open: false\n        });\n      },\n      invokeOnDragEnd({\n        context,\n        prop\n      }) {\n        prop(\"onPositionChangeEnd\")?.({\n          position: context.get(\"position\")\n        });\n      },\n      invokeOnResizeEnd({\n        context,\n        prop\n      }) {\n        prop(\"onSizeChangeEnd\")?.({\n          size: context.get(\"size\")\n        });\n      },\n      focusTriggerEl({\n        scope\n      }) {\n        raf(() => {\n          getTriggerEl(scope)?.focus();\n        });\n      },\n      focusContentEl({\n        scope\n      }) {\n        raf(() => {\n          getContentEl(scope)?.focus();\n        });\n      },\n      toggleVisibility({\n        send,\n        prop,\n        event\n      }) {\n        send({\n          type: prop(\"open\") ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\",\n          previousEvent: event\n        });\n      }\n    }\n  }\n});\nvar props = createProps()([\"allowOverflow\", \"closeOnEscape\", \"defaultOpen\", \"defaultPosition\", \"defaultSize\", \"dir\", \"disabled\", \"draggable\", \"getAnchorPosition\", \"getBoundaryEl\", \"getRootNode\", \"gridSize\", \"id\", \"ids\", \"lockAspectRatio\", \"maxSize\", \"minSize\", \"onOpenChange\", \"onPositionChange\", \"onPositionChangeEnd\", \"onSizeChange\", \"onSizeChangeEnd\", \"onStageChange\", \"open\", \"persistRect\", \"position\", \"resizable\", \"size\", \"strategy\", \"translations\"]);\nvar splitProps = createSplitProps(props);\nvar resizeTriggerProps = createProps()([\"axis\"]);\nvar splitResizeTriggerProps = createSplitProps(resizeTriggerProps);\nexport { anatomy, connect, machine, props, resizeTriggerProps, splitProps, splitResizeTriggerProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}