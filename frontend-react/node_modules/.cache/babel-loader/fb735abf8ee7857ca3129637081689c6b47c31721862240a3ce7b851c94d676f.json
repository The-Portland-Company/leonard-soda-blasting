{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { raf, setElementValue, trackPointerMove, dataAttr, getEventStep, getEventPoint } from '@zag-js/dom-query';\nimport { createRect, getPointAngle } from '@zag-js/rect-utils';\nimport { snapValueToStep, createSplitProps } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/angle-slider.anatomy.ts\nvar anatomy = createAnatomy(\"angle-slider\").parts(\"root\", \"label\", \"thumb\", \"valueText\", \"control\", \"track\", \"markerGroup\", \"marker\");\nvar parts = anatomy.build();\n\n// src/angle-slider.dom.ts\nvar getRootId = ctx => ctx.ids?.root ?? `angle-slider:${ctx.id}`;\nvar getThumbId = ctx => ctx.ids?.thumb ?? `angle-slider:${ctx.id}:thumb`;\nvar getHiddenInputId = ctx => ctx.ids?.hiddenInput ?? `angle-slider:${ctx.id}:input`;\nvar getControlId = ctx => ctx.ids?.control ?? `angle-slider:${ctx.id}:control`;\nvar getValueTextId = ctx => ctx.ids?.valueText ?? `angle-slider:${ctx.id}:value-text`;\nvar getHiddenInputEl = ctx => ctx.getById(getHiddenInputId(ctx));\nvar getControlEl = ctx => ctx.getById(getControlId(ctx));\nvar getThumbEl = ctx => ctx.getById(getThumbId(ctx));\n\n// src/angle-slider.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    context,\n    prop,\n    computed,\n    scope\n  } = service;\n  const dragging = state.matches(\"dragging\");\n  const value = context.get(\"value\");\n  const valueAsDegree = computed(\"valueAsDegree\");\n  const disabled = prop(\"disabled\");\n  const invalid = prop(\"invalid\");\n  const readOnly = prop(\"readOnly\");\n  const interactive = computed(\"interactive\");\n  return {\n    value,\n    valueAsDegree,\n    dragging,\n    setValue(value2) {\n      send({\n        type: \"VALUE.SET\",\n        value: value2\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: getRootId(scope),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly),\n        style: {\n          \"--value\": value,\n          \"--angle\": valueAsDegree\n        }\n      });\n    },\n    getLabelProps() {\n      return normalize.label({\n        ...parts.label.attrs,\n        htmlFor: getHiddenInputId(scope),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly),\n        onClick(event) {\n          if (!interactive) return;\n          event.preventDefault();\n          getThumbEl(scope)?.focus();\n        }\n      });\n    },\n    getHiddenInputProps() {\n      return normalize.element({\n        type: \"hidden\",\n        value,\n        name: prop(\"name\"),\n        id: getHiddenInputId(scope)\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        role: \"presentation\",\n        id: getControlId(scope),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly),\n        onPointerDown(event) {\n          if (!interactive) return;\n          const point = getEventPoint(event);\n          send({\n            type: \"CONTROL.POINTER_DOWN\",\n            point\n          });\n        }\n      });\n    },\n    getThumbProps() {\n      return normalize.element({\n        ...parts.thumb.attrs,\n        id: getThumbId(scope),\n        role: \"slider\",\n        \"aria-valuemax\": 360,\n        \"aria-valuemin\": 0,\n        \"aria-valuenow\": value,\n        tabIndex: readOnly || interactive ? 0 : void 0,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly),\n        onFocus() {\n          send({\n            type: \"THUMB.FOCUS\"\n          });\n        },\n        onBlur() {\n          send({\n            type: \"THUMB.BLUR\"\n          });\n        },\n        onKeyDown(event) {\n          if (!interactive) return;\n          const step = getEventStep(event) * prop(\"step\");\n          switch (event.key) {\n            case \"ArrowLeft\":\n            case \"ArrowUp\":\n              event.preventDefault();\n              send({\n                type: \"THUMB.ARROW_DEC\",\n                step\n              });\n              break;\n            case \"ArrowRight\":\n            case \"ArrowDown\":\n              event.preventDefault();\n              send({\n                type: \"THUMB.ARROW_INC\",\n                step\n              });\n              break;\n            case \"Home\":\n              event.preventDefault();\n              send({\n                type: \"THUMB.HOME\"\n              });\n              break;\n            case \"End\":\n              event.preventDefault();\n              send({\n                type: \"THUMB.END\"\n              });\n              break;\n          }\n        },\n        style: {\n          rotate: `var(--angle)`\n        }\n      });\n    },\n    getValueTextProps() {\n      return normalize.element({\n        ...parts.valueText.attrs,\n        id: getValueTextId(scope)\n      });\n    },\n    getMarkerGroupProps() {\n      return normalize.element({\n        ...parts.markerGroup.attrs\n      });\n    },\n    getMarkerProps(props2) {\n      let markerState;\n      if (props2.value < value) {\n        markerState = \"under-value\";\n      } else if (props2.value > value) {\n        markerState = \"over-value\";\n      } else {\n        markerState = \"at-value\";\n      }\n      return normalize.element({\n        ...parts.marker.attrs,\n        \"data-value\": props2.value,\n        \"data-state\": markerState,\n        \"data-disabled\": dataAttr(disabled),\n        style: {\n          \"--marker-value\": props2.value,\n          rotate: `calc(var(--marker-value) * 1deg)`\n        }\n      });\n    }\n  };\n}\nvar MIN_VALUE = 0;\nvar MAX_VALUE = 359;\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    return {\n      step: 1,\n      defaultValue: 0,\n      ...props2\n    };\n  },\n  context({\n    prop,\n    bindable\n  }) {\n    return {\n      value: bindable(() => ({\n        defaultValue: prop(\"defaultValue\"),\n        value: prop(\"value\"),\n        onChange(value) {\n          prop(\"onValueChange\")?.({\n            value,\n            valueAsDegree: `${value}deg`\n          });\n        }\n      }))\n    };\n  },\n  computed: {\n    interactive: ({\n      prop\n    }) => !(prop(\"disabled\") || prop(\"readOnly\")),\n    valueAsDegree: ({\n      context\n    }) => `${context.get(\"value\")}deg`\n  },\n  watch({\n    track,\n    context,\n    action\n  }) {\n    track([() => context.get(\"value\")], () => {\n      action([\"syncInputElement\"]);\n    });\n  },\n  initialState() {\n    return \"idle\";\n  },\n  on: {\n    \"VALUE.SET\": {\n      actions: [\"setValue\"]\n    }\n  },\n  states: {\n    idle: {\n      on: {\n        \"CONTROL.POINTER_DOWN\": {\n          target: \"dragging\",\n          actions: [\"setPointerValue\", \"focusThumb\"]\n        },\n        \"THUMB.FOCUS\": {\n          target: \"focused\"\n        }\n      }\n    },\n    focused: {\n      on: {\n        \"CONTROL.POINTER_DOWN\": {\n          target: \"dragging\",\n          actions: [\"setPointerValue\", \"focusThumb\"]\n        },\n        \"THUMB.ARROW_DEC\": {\n          actions: [\"decrementValue\", \"invokeOnChangeEnd\"]\n        },\n        \"THUMB.ARROW_INC\": {\n          actions: [\"incrementValue\", \"invokeOnChangeEnd\"]\n        },\n        \"THUMB.HOME\": {\n          actions: [\"setValueToMin\", \"invokeOnChangeEnd\"]\n        },\n        \"THUMB.END\": {\n          actions: [\"setValueToMax\", \"invokeOnChangeEnd\"]\n        },\n        \"THUMB.BLUR\": {\n          target: \"idle\"\n        }\n      }\n    },\n    dragging: {\n      entry: [\"focusThumb\"],\n      effects: [\"trackPointerMove\"],\n      on: {\n        \"DOC.POINTER_UP\": {\n          target: \"focused\",\n          actions: [\"invokeOnChangeEnd\"]\n        },\n        \"DOC.POINTER_MOVE\": {\n          actions: [\"setPointerValue\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      trackPointerMove({\n        scope,\n        send\n      }) {\n        return trackPointerMove(scope.getDoc(), {\n          onPointerMove(info) {\n            send({\n              type: \"DOC.POINTER_MOVE\",\n              point: info.point\n            });\n          },\n          onPointerUp() {\n            send({\n              type: \"DOC.POINTER_UP\"\n            });\n          }\n        });\n      }\n    },\n    actions: {\n      syncInputElement({\n        scope,\n        context\n      }) {\n        const inputEl = getHiddenInputEl(scope);\n        setElementValue(inputEl, context.get(\"value\").toString());\n      },\n      invokeOnChangeEnd({\n        context,\n        prop,\n        computed\n      }) {\n        prop(\"onValueChangeEnd\")?.({\n          value: context.get(\"value\"),\n          valueAsDegree: computed(\"valueAsDegree\")\n        });\n      },\n      setPointerValue({\n        scope,\n        event,\n        context,\n        prop\n      }) {\n        const controlEl = getControlEl(scope);\n        if (!controlEl) return;\n        const deg = getAngle(controlEl, event.point);\n        context.set(\"value\", constrainAngle(deg, prop(\"step\")));\n      },\n      setValueToMin({\n        context\n      }) {\n        context.set(\"value\", MIN_VALUE);\n      },\n      setValueToMax({\n        context\n      }) {\n        context.set(\"value\", MAX_VALUE);\n      },\n      setValue({\n        context,\n        event\n      }) {\n        context.set(\"value\", clampAngle(event.value));\n      },\n      decrementValue({\n        context,\n        event,\n        prop\n      }) {\n        const value = snapValueToStep(context.get(\"value\") - event.step, MIN_VALUE, MAX_VALUE, event.step ?? prop(\"step\"));\n        context.set(\"value\", value);\n      },\n      incrementValue({\n        context,\n        event,\n        prop\n      }) {\n        const value = snapValueToStep(context.get(\"value\") + event.step, MIN_VALUE, MAX_VALUE, event.step ?? prop(\"step\"));\n        context.set(\"value\", value);\n      },\n      focusThumb({\n        scope\n      }) {\n        raf(() => {\n          getThumbEl(scope)?.focus({\n            preventScroll: true\n          });\n        });\n      }\n    }\n  }\n});\nfunction getAngle(controlEl, point) {\n  const rect = createRect(controlEl.getBoundingClientRect());\n  return getPointAngle(rect, point);\n}\nfunction clampAngle(degree) {\n  return Math.min(Math.max(degree, MIN_VALUE), MAX_VALUE);\n}\nfunction constrainAngle(degree, step) {\n  const clampedDegree = clampAngle(degree);\n  const upperStep = Math.ceil(clampedDegree / step);\n  const nearestStep = Math.round(clampedDegree / step);\n  return upperStep >= clampedDegree / step ? upperStep * step === MAX_VALUE ? MIN_VALUE : upperStep * step : nearestStep * step;\n}\nvar props = createProps()([\"dir\", \"disabled\", \"getRootNode\", \"id\", \"ids\", \"invalid\", \"name\", \"onValueChange\", \"onValueChangeEnd\", \"readOnly\", \"step\", \"value\", \"defaultValue\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}