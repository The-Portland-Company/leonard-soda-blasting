{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { Selection, ListCollection, GridCollection, isGridCollection } from '@zag-js/collection';\nimport { raf, observeAttributes, getByTypeahead, scrollIntoView, dataAttr, isSelfTarget, getEventKey, getEventTarget, isEditableElement, ariaAttr, isCtrlOrMetaKey, isComposingEvent, getNativeEvent, getWindow } from '@zag-js/dom-query';\nimport { isEqual, createSplitProps, ensure } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { trackFocusVisible, getInteractionModality } from '@zag-js/focus-visible';\nimport { createProps } from '@zag-js/types';\n\n// src/listbox.anatomy.ts\nvar anatomy = createAnatomy(\"listbox\").parts(\"label\", \"input\", \"item\", \"itemText\", \"itemIndicator\", \"itemGroup\", \"itemGroupLabel\", \"content\", \"root\", \"valueText\");\nvar parts = anatomy.build();\nvar collection = options => {\n  return new ListCollection(options);\n};\ncollection.empty = () => {\n  return new ListCollection({\n    items: []\n  });\n};\nvar gridCollection = options => {\n  return new GridCollection(options);\n};\ngridCollection.empty = () => {\n  return new GridCollection({\n    items: [],\n    columnCount: 0\n  });\n};\n\n// src/listbox.dom.ts\nvar getRootId = ctx => ctx.ids?.root ?? `select:${ctx.id}`;\nvar getContentId = ctx => ctx.ids?.content ?? `select:${ctx.id}:content`;\nvar getLabelId = ctx => ctx.ids?.label ?? `select:${ctx.id}:label`;\nvar getItemId = (ctx, id) => ctx.ids?.item?.(id) ?? `select:${ctx.id}:option:${id}`;\nvar getItemGroupId = (ctx, id) => ctx.ids?.itemGroup?.(id) ?? `select:${ctx.id}:optgroup:${id}`;\nvar getItemGroupLabelId = (ctx, id) => ctx.ids?.itemGroupLabel?.(id) ?? `select:${ctx.id}:optgroup-label:${id}`;\nvar getContentEl = ctx => ctx.getById(getContentId(ctx));\nvar getItemEl = (ctx, id) => ctx.getById(getItemId(ctx, id));\n\n// src/listbox.connect.ts\nfunction connect(service, normalize) {\n  const {\n    context,\n    prop,\n    scope,\n    computed,\n    send\n  } = service;\n  const disabled = prop(\"disabled\");\n  const collection2 = prop(\"collection\");\n  const layout = isGridCollection(collection2) ? \"grid\" : \"list\";\n  const value = context.get(\"value\");\n  const highlightedValue = context.get(\"highlightedValue\");\n  const highlightedItem = context.get(\"highlightedItem\");\n  const selectedItems = context.get(\"selectedItems\");\n  const isTypingAhead = computed(\"isTypingAhead\");\n  const interactive = computed(\"isInteractive\");\n  const ariaActiveDescendant = highlightedValue ? getItemId(scope, highlightedValue) : void 0;\n  function getItemState(props2) {\n    const itemDisabled = collection2.getItemDisabled(props2.item);\n    const value2 = collection2.getItemValue(props2.item);\n    ensure(value2, () => `[zag-js] No value found for item ${JSON.stringify(props2.item)}`);\n    return {\n      value: value2,\n      disabled: Boolean(disabled || itemDisabled),\n      highlighted: highlightedValue === value2 && context.get(\"focused\"),\n      selected: context.get(\"value\").includes(value2)\n    };\n  }\n  return {\n    empty: value.length === 0,\n    highlightedItem,\n    highlightedValue,\n    clearHighlightedValue() {\n      send({\n        type: \"HIGHLIGHTED_VALUE.SET\",\n        value: null\n      });\n    },\n    selectedItems,\n    hasSelectedItems: computed(\"hasSelectedItems\"),\n    value,\n    valueAsString: context.get(\"valueAsString\"),\n    collection: collection2,\n    disabled: !!disabled,\n    selectValue(value2) {\n      send({\n        type: \"ITEM.SELECT\",\n        value: value2\n      });\n    },\n    setValue(value2) {\n      send({\n        type: \"VALUE.SET\",\n        value: value2\n      });\n    },\n    selectAll() {\n      if (!computed(\"multiple\")) {\n        throw new Error(\"[zag-js] Cannot select all items in a single-select listbox\");\n      }\n      send({\n        type: \"VALUE.SET\",\n        value: collection2.getValues()\n      });\n    },\n    highlightValue(value2) {\n      send({\n        type: \"HIGHLIGHTED_VALUE.SET\",\n        value: value2\n      });\n    },\n    clearValue(value2) {\n      if (value2) {\n        send({\n          type: \"ITEM.CLEAR\",\n          value: value2\n        });\n      } else {\n        send({\n          type: \"VALUE.CLEAR\"\n        });\n      }\n    },\n    getItemState,\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: prop(\"dir\"),\n        id: getRootId(scope),\n        \"data-orientation\": prop(\"orientation\"),\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getInputProps(props2 = {}) {\n      return normalize.input({\n        ...parts.input.attrs,\n        dir: prop(\"dir\"),\n        disabled,\n        \"data-disabled\": dataAttr(disabled),\n        autoComplete: \"off\",\n        autoCorrect: \"off\",\n        \"aria-haspopup\": \"listbox\",\n        \"aria-controls\": getContentId(scope),\n        \"aria-autocomplete\": \"list\",\n        \"aria-activedescendant\": ariaActiveDescendant,\n        spellCheck: false,\n        enterKeyHint: \"go\",\n        onFocus() {\n          queueMicrotask(() => {\n            const contentEl = getContentEl(scope);\n            const win = getWindow(contentEl);\n            const focusInEvt = new win.FocusEvent(\"focusin\", {\n              bubbles: true,\n              cancelable: true\n            });\n            contentEl?.dispatchEvent(focusInEvt);\n          });\n        },\n        onBlur(event) {\n          if (event.defaultPrevented) return;\n          const contentEl = getContentEl(scope);\n          const win = getWindow(contentEl);\n          const focusOutEvt = new win.FocusEvent(\"focusout\", {\n            bubbles: true,\n            cancelable: true\n          });\n          contentEl?.dispatchEvent(focusOutEvt);\n        },\n        onInput(event) {\n          if (!props2.autoHighlight) return;\n          const node = event.currentTarget;\n          queueMicrotask(() => {\n            if (!node.isConnected) return;\n            send({\n              type: \"HIGHLIGHTED_VALUE.SET\",\n              value: node.value ? prop(\"collection\").firstValue : null\n            });\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (isComposingEvent(event)) return;\n          const nativeEvent = getNativeEvent(event);\n          switch (nativeEvent.key) {\n            case \"ArrowDown\":\n            case \"ArrowUp\":\n            case \"Home\":\n            case \"End\":\n              {\n                if ((event.key === \"Home\" || event.key === \"End\") && !highlightedValue && event.shiftKey) {\n                  return;\n                }\n                event.preventDefault();\n                const win = scope.getWin();\n                const keyboardEvent = new win.KeyboardEvent(nativeEvent.type, nativeEvent);\n                getContentEl(scope)?.dispatchEvent(keyboardEvent);\n                break;\n              }\n            case \"Enter\":\n              event.preventDefault();\n              send({\n                type: \"ITEM.CLICK\",\n                value: highlightedValue\n              });\n              break;\n          }\n        }\n      });\n    },\n    getLabelProps() {\n      return normalize.element({\n        dir: prop(\"dir\"),\n        id: getLabelId(scope),\n        ...parts.label.attrs,\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getValueTextProps() {\n      return normalize.element({\n        ...parts.valueText.attrs,\n        dir: prop(\"dir\"),\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getItemProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        id: getItemId(scope, itemState.value),\n        role: \"option\",\n        ...parts.item.attrs,\n        dir: prop(\"dir\"),\n        \"data-value\": itemState.value,\n        \"aria-selected\": itemState.selected,\n        \"data-selected\": dataAttr(itemState.selected),\n        \"data-layout\": layout,\n        \"data-state\": itemState.selected ? \"checked\" : \"unchecked\",\n        \"data-orientation\": prop(\"orientation\"),\n        \"data-highlighted\": dataAttr(itemState.highlighted),\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"aria-disabled\": ariaAttr(itemState.disabled),\n        onPointerMove(event) {\n          if (!props2.highlightOnHover) return;\n          if (itemState.disabled || event.pointerType !== \"mouse\") return;\n          if (itemState.highlighted) return;\n          send({\n            type: \"ITEM.POINTER_MOVE\",\n            value: itemState.value\n          });\n        },\n        onMouseDown(event) {\n          event.preventDefault();\n          getContentEl(scope)?.focus();\n        },\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (itemState.disabled) return;\n          send({\n            type: \"ITEM.CLICK\",\n            value: itemState.value,\n            shiftKey: event.shiftKey,\n            anchorValue: highlightedValue,\n            metaKey: isCtrlOrMetaKey(event)\n          });\n        }\n      });\n    },\n    getItemTextProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        ...parts.itemText.attrs,\n        \"data-state\": itemState.selected ? \"checked\" : \"unchecked\",\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-highlighted\": dataAttr(itemState.highlighted)\n      });\n    },\n    getItemIndicatorProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        ...parts.itemIndicator.attrs,\n        \"aria-hidden\": true,\n        \"data-state\": itemState.selected ? \"checked\" : \"unchecked\",\n        hidden: !itemState.selected\n      });\n    },\n    getItemGroupLabelProps(props2) {\n      const {\n        htmlFor\n      } = props2;\n      return normalize.element({\n        ...parts.itemGroupLabel.attrs,\n        id: getItemGroupLabelId(scope, htmlFor),\n        dir: prop(\"dir\"),\n        role: \"presentation\"\n      });\n    },\n    getItemGroupProps(props2) {\n      const {\n        id\n      } = props2;\n      return normalize.element({\n        ...parts.itemGroup.attrs,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-orientation\": prop(\"orientation\"),\n        \"data-empty\": dataAttr(collection2.size === 0),\n        id: getItemGroupId(scope, id),\n        \"aria-labelledby\": getItemGroupLabelId(scope, id),\n        role: \"group\",\n        dir: prop(\"dir\")\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        dir: prop(\"dir\"),\n        id: getContentId(scope),\n        role: \"listbox\",\n        ...parts.content.attrs,\n        \"data-activedescendant\": ariaActiveDescendant,\n        \"aria-activedescendant\": ariaActiveDescendant,\n        \"data-orientation\": prop(\"orientation\"),\n        \"aria-multiselectable\": computed(\"multiple\") ? true : void 0,\n        \"aria-labelledby\": getLabelId(scope),\n        tabIndex: 0,\n        \"data-layout\": layout,\n        \"data-empty\": dataAttr(collection2.size === 0),\n        style: {\n          \"--column-count\": isGridCollection(collection2) ? collection2.columnCount : 1\n        },\n        onFocus() {\n          send({\n            type: \"CONTENT.FOCUS\"\n          });\n        },\n        onBlur() {\n          send({\n            type: \"CONTENT.BLUR\"\n          });\n        },\n        onKeyDown(event) {\n          if (!interactive) return;\n          if (!isSelfTarget(event)) return;\n          const shiftKey = event.shiftKey;\n          const keyMap = {\n            ArrowUp(event2) {\n              let nextValue = null;\n              if (isGridCollection(collection2) && highlightedValue) {\n                nextValue = collection2.getPreviousRowValue(highlightedValue);\n              } else if (highlightedValue) {\n                nextValue = collection2.getPreviousValue(highlightedValue);\n              }\n              if (!nextValue && (prop(\"loopFocus\") || !highlightedValue)) {\n                nextValue = collection2.lastValue;\n              }\n              if (!nextValue) return;\n              event2.preventDefault();\n              send({\n                type: \"NAVIGATE\",\n                value: nextValue,\n                shiftKey,\n                anchorValue: highlightedValue\n              });\n            },\n            ArrowDown(event2) {\n              let nextValue = null;\n              if (isGridCollection(collection2) && highlightedValue) {\n                nextValue = collection2.getNextRowValue(highlightedValue);\n              } else if (highlightedValue) {\n                nextValue = collection2.getNextValue(highlightedValue);\n              }\n              if (!nextValue && (prop(\"loopFocus\") || !highlightedValue)) {\n                nextValue = collection2.firstValue;\n              }\n              if (!nextValue) return;\n              event2.preventDefault();\n              send({\n                type: \"NAVIGATE\",\n                value: nextValue,\n                shiftKey,\n                anchorValue: highlightedValue\n              });\n            },\n            ArrowLeft() {\n              if (!isGridCollection(collection2) && prop(\"orientation\") === \"vertical\") return;\n              let nextValue = highlightedValue ? collection2.getPreviousValue(highlightedValue) : null;\n              if (!nextValue && prop(\"loopFocus\")) {\n                nextValue = collection2.lastValue;\n              }\n              if (!nextValue) return;\n              event.preventDefault();\n              send({\n                type: \"NAVIGATE\",\n                value: nextValue,\n                shiftKey,\n                anchorValue: highlightedValue\n              });\n            },\n            ArrowRight() {\n              if (!isGridCollection(collection2) && prop(\"orientation\") === \"vertical\") return;\n              let nextValue = highlightedValue ? collection2.getNextValue(highlightedValue) : null;\n              if (!nextValue && prop(\"loopFocus\")) {\n                nextValue = collection2.firstValue;\n              }\n              if (!nextValue) return;\n              event.preventDefault();\n              send({\n                type: \"NAVIGATE\",\n                value: nextValue,\n                shiftKey,\n                anchorValue: highlightedValue\n              });\n            },\n            Home(event2) {\n              event2.preventDefault();\n              let nextValue = collection2.firstValue;\n              send({\n                type: \"NAVIGATE\",\n                value: nextValue,\n                shiftKey,\n                anchorValue: highlightedValue\n              });\n            },\n            End(event2) {\n              event2.preventDefault();\n              let nextValue = collection2.lastValue;\n              send({\n                type: \"NAVIGATE\",\n                value: nextValue,\n                shiftKey,\n                anchorValue: highlightedValue\n              });\n            },\n            Enter() {\n              send({\n                type: \"ITEM.CLICK\",\n                value: highlightedValue\n              });\n            },\n            a(event2) {\n              if (isCtrlOrMetaKey(event2) && computed(\"multiple\") && !prop(\"disallowSelectAll\")) {\n                event2.preventDefault();\n                send({\n                  type: \"VALUE.SET\",\n                  value: collection2.getValues()\n                });\n              }\n            },\n            Space(event2) {\n              if (isTypingAhead && prop(\"typeahead\")) {\n                send({\n                  type: \"CONTENT.TYPEAHEAD\",\n                  key: event2.key\n                });\n              } else {\n                keyMap.Enter?.(event2);\n              }\n            },\n            Escape(event2) {\n              if (prop(\"deselectable\") && value.length > 0) {\n                event2.preventDefault();\n                event2.stopPropagation();\n                send({\n                  type: \"VALUE.CLEAR\"\n                });\n              }\n            }\n          };\n          const exec = keyMap[getEventKey(event)];\n          if (exec) {\n            exec(event);\n            return;\n          }\n          const target = getEventTarget(event);\n          if (isEditableElement(target)) {\n            return;\n          }\n          if (getByTypeahead.isValidEvent(event) && prop(\"typeahead\")) {\n            send({\n              type: \"CONTENT.TYPEAHEAD\",\n              key: event.key\n            });\n            event.preventDefault();\n          }\n        }\n      });\n    }\n  };\n}\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    return {\n      loopFocus: false,\n      composite: true,\n      defaultValue: [],\n      multiple: false,\n      typeahead: true,\n      collection: collection.empty(),\n      orientation: \"vertical\",\n      selectionMode: \"single\",\n      ...props2\n    };\n  },\n  context({\n    prop,\n    bindable\n  }) {\n    return {\n      value: bindable(() => ({\n        defaultValue: prop(\"defaultValue\"),\n        value: prop(\"value\"),\n        isEqual,\n        onChange(value) {\n          const items = prop(\"collection\").findMany(value);\n          return prop(\"onValueChange\")?.({\n            value,\n            items\n          });\n        }\n      })),\n      highlightedValue: bindable(() => ({\n        defaultValue: prop(\"defaultHighlightedValue\") || null,\n        value: prop(\"highlightedValue\"),\n        sync: true,\n        onChange(value) {\n          prop(\"onHighlightChange\")?.({\n            highlightedValue: value,\n            highlightedItem: prop(\"collection\").find(value),\n            highlightedIndex: prop(\"collection\").indexOf(value)\n          });\n        }\n      })),\n      highlightedItem: bindable(() => ({\n        defaultValue: null\n      })),\n      selectedItems: bindable(() => {\n        const value = prop(\"value\") ?? prop(\"defaultValue\") ?? [];\n        const items = prop(\"collection\").findMany(value);\n        return {\n          defaultValue: items\n        };\n      }),\n      valueAsString: bindable(() => {\n        const value = prop(\"value\") ?? prop(\"defaultValue\") ?? [];\n        return {\n          defaultValue: prop(\"collection\").stringifyMany(value)\n        };\n      }),\n      focused: bindable(() => ({\n        defaultValue: false\n      }))\n    };\n  },\n  refs({\n    prop\n  }) {\n    return {\n      typeahead: {\n        ...getByTypeahead.defaultOptions\n      },\n      prevCollection: prop(\"collection\")\n    };\n  },\n  computed: {\n    hasSelectedItems: ({\n      context\n    }) => context.get(\"value\").length > 0,\n    isTypingAhead: ({\n      refs\n    }) => refs.get(\"typeahead\").keysSoFar !== \"\",\n    isInteractive: ({\n      prop\n    }) => !prop(\"disabled\"),\n    selection: ({\n      context,\n      prop\n    }) => {\n      const selection = new Selection(context.get(\"value\"));\n      selection.selectionMode = prop(\"selectionMode\");\n      selection.deselectable = !!prop(\"deselectable\");\n      return selection;\n    },\n    multiple: ({\n      prop\n    }) => prop(\"selectionMode\") === \"multiple\" || prop(\"selectionMode\") === \"extended\"\n  },\n  initialState() {\n    return \"idle\";\n  },\n  watch({\n    context,\n    prop,\n    track,\n    action\n  }) {\n    track([() => context.get(\"value\").toString()], () => {\n      action([\"syncSelectedItems\"]);\n    });\n    track([() => context.get(\"highlightedValue\")], () => {\n      action([\"syncHighlightedItem\"]);\n    });\n    track([() => prop(\"collection\").toString()], () => {\n      action([\"syncCollection\"]);\n    });\n  },\n  effects: [\"trackFocusVisible\"],\n  on: {\n    \"HIGHLIGHTED_VALUE.SET\": {\n      actions: [\"setHighlightedItem\"]\n    },\n    \"ITEM.SELECT\": {\n      actions: [\"selectItem\"]\n    },\n    \"ITEM.CLEAR\": {\n      actions: [\"clearItem\"]\n    },\n    \"VALUE.SET\": {\n      actions: [\"setSelectedItems\"]\n    },\n    \"VALUE.CLEAR\": {\n      actions: [\"clearSelectedItems\"]\n    },\n    \"CLEAR.CLICK\": {\n      actions: [\"clearSelectedItems\"]\n    }\n  },\n  states: {\n    idle: {\n      effects: [\"scrollToHighlightedItem\"],\n      on: {\n        \"CONTENT.FOCUS\": {\n          actions: [\"setFocused\"]\n        },\n        \"CONTENT.BLUR\": {\n          actions: [\"clearFocused\"]\n        },\n        \"ITEM.CLICK\": {\n          actions: [\"setHighlightedItem\", \"selectHighlightedItem\"]\n        },\n        \"CONTENT.TYPEAHEAD\": {\n          actions: [\"highlightMatchingItem\"]\n        },\n        \"ITEM.POINTER_MOVE\": {\n          actions: [\"highlightItem\"]\n        },\n        \"ITEM.POINTER_LEAVE\": {\n          actions: [\"clearHighlightedItem\"]\n        },\n        NAVIGATE: {\n          actions: [\"setHighlightedItem\", \"selectWithKeyboard\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      trackFocusVisible: ({\n        scope\n      }) => {\n        return trackFocusVisible({\n          root: scope.getRootNode?.()\n        });\n      },\n      scrollToHighlightedItem({\n        context,\n        prop,\n        scope\n      }) {\n        const exec = immediate => {\n          const highlightedValue = context.get(\"highlightedValue\");\n          if (highlightedValue == null) return;\n          const modality = getInteractionModality();\n          if (modality !== \"keyboard\") return;\n          const itemEl = getItemEl(scope, highlightedValue);\n          const contentEl2 = getContentEl(scope);\n          const scrollToIndexFn = prop(\"scrollToIndexFn\");\n          if (scrollToIndexFn) {\n            const highlightedIndex = prop(\"collection\").indexOf(highlightedValue);\n            scrollToIndexFn?.({\n              index: highlightedIndex,\n              immediate\n            });\n            return;\n          }\n          scrollIntoView(itemEl, {\n            rootEl: contentEl2,\n            block: \"nearest\"\n          });\n        };\n        raf(() => exec(true));\n        const contentEl = () => getContentEl(scope);\n        return observeAttributes(contentEl, {\n          defer: true,\n          attributes: [\"data-activedescendant\"],\n          callback() {\n            exec(false);\n          }\n        });\n      }\n    },\n    actions: {\n      selectHighlightedItem({\n        context,\n        prop,\n        event,\n        computed\n      }) {\n        const value = event.value ?? context.get(\"highlightedValue\");\n        if (value == null) return;\n        const selection = computed(\"selection\");\n        const collection2 = prop(\"collection\");\n        if (event.shiftKey && computed(\"multiple\") && event.anchorValue) {\n          const next = selection.extendSelection(collection2, event.anchorValue, value);\n          invokeOnSelect(selection, next, prop(\"onSelect\"));\n          context.set(\"value\", Array.from(next));\n        } else {\n          const next = selection.select(collection2, value, event.metaKey);\n          invokeOnSelect(selection, next, prop(\"onSelect\"));\n          context.set(\"value\", Array.from(next));\n        }\n      },\n      selectWithKeyboard({\n        context,\n        prop,\n        event,\n        computed\n      }) {\n        const selection = computed(\"selection\");\n        const collection2 = prop(\"collection\");\n        if (event.shiftKey && computed(\"multiple\") && event.anchorValue) {\n          const next = selection.extendSelection(collection2, event.anchorValue, event.value);\n          invokeOnSelect(selection, next, prop(\"onSelect\"));\n          context.set(\"value\", Array.from(next));\n          return;\n        }\n        if (prop(\"selectOnHighlight\")) {\n          const next = selection.replaceSelection(collection2, event.value);\n          invokeOnSelect(selection, next, prop(\"onSelect\"));\n          context.set(\"value\", Array.from(next));\n        }\n      },\n      highlightItem({\n        context,\n        event\n      }) {\n        context.set(\"highlightedValue\", event.value);\n      },\n      highlightMatchingItem({\n        context,\n        prop,\n        event,\n        refs\n      }) {\n        const value = prop(\"collection\").search(event.key, {\n          state: refs.get(\"typeahead\"),\n          currentValue: context.get(\"highlightedValue\")\n        });\n        if (value == null) return;\n        context.set(\"highlightedValue\", value);\n      },\n      setHighlightedItem({\n        context,\n        event\n      }) {\n        context.set(\"highlightedValue\", event.value);\n      },\n      clearHighlightedItem({\n        context\n      }) {\n        context.set(\"highlightedValue\", null);\n      },\n      selectItem({\n        context,\n        prop,\n        event,\n        computed\n      }) {\n        const collection2 = prop(\"collection\");\n        const selection = computed(\"selection\");\n        const next = selection.select(collection2, event.value);\n        invokeOnSelect(selection, next, prop(\"onSelect\"));\n        context.set(\"value\", Array.from(next));\n      },\n      clearItem({\n        context,\n        event,\n        computed\n      }) {\n        const selection = computed(\"selection\");\n        const value = selection.deselect(event.value);\n        context.set(\"value\", Array.from(value));\n      },\n      setSelectedItems({\n        context,\n        event\n      }) {\n        context.set(\"value\", event.value);\n      },\n      clearSelectedItems({\n        context\n      }) {\n        context.set(\"value\", []);\n      },\n      syncCollection({\n        context,\n        prop,\n        refs\n      }) {\n        const collection2 = prop(\"collection\");\n        const highlightedItem = collection2.find(context.get(\"highlightedValue\"));\n        if (highlightedItem) context.set(\"highlightedItem\", highlightedItem);\n        const selectedItems = collection2.findMany(context.get(\"value\"));\n        context.set(\"selectedItems\", selectedItems);\n        const valueAsString = collection2.stringifyItems(selectedItems);\n        context.set(\"valueAsString\", valueAsString);\n        const highlightedValue = syncHighlightedValue(collection2, refs.get(\"prevCollection\"), context.get(\"highlightedValue\"));\n        queueMicrotask(() => {\n          context.set(\"highlightedValue\", highlightedValue);\n          refs.set(\"prevCollection\", collection2);\n        });\n      },\n      syncSelectedItems({\n        context,\n        prop\n      }) {\n        const collection2 = prop(\"collection\");\n        const prevSelectedItems = context.get(\"selectedItems\");\n        const value = context.get(\"value\");\n        const selectedItems = value.map(value2 => {\n          const item = prevSelectedItems.find(item2 => collection2.getItemValue(item2) === value2);\n          return item || collection2.find(value2);\n        });\n        context.set(\"selectedItems\", selectedItems);\n        context.set(\"valueAsString\", collection2.stringifyItems(selectedItems));\n      },\n      syncHighlightedItem({\n        context,\n        prop\n      }) {\n        const collection2 = prop(\"collection\");\n        const highlightedValue = context.get(\"highlightedValue\");\n        const highlightedItem = highlightedValue ? collection2.find(highlightedValue) : null;\n        context.set(\"highlightedItem\", highlightedItem);\n      },\n      setFocused({\n        context\n      }) {\n        context.set(\"focused\", true);\n      },\n      clearFocused({\n        context\n      }) {\n        context.set(\"focused\", false);\n      }\n    }\n  }\n});\nvar diff = (a, b) => {\n  const result = new Set(a);\n  for (const item of b) result.delete(item);\n  return result;\n};\nfunction invokeOnSelect(current, next, onSelect) {\n  const added = diff(next, current);\n  for (const item of added) {\n    onSelect?.({\n      value: item\n    });\n  }\n}\nfunction syncHighlightedValue(collection2, prevCollection, highlightedValue) {\n  if (highlightedValue != null && !collection2.find(highlightedValue) && prevCollection) {\n    const startIndex = prevCollection.indexOf(highlightedValue);\n    const prevItems = [...prevCollection.items];\n    const items = [...collection2.items];\n    const diff2 = (prevItems?.length ?? 0) - (items?.length ?? 0);\n    let index = Math.min(diff2 > 1 ? Math.max((startIndex ?? 0) - diff2 + 1, 0) : startIndex ?? 0, (items?.length ?? 0) - 1);\n    let newValue = null;\n    let isReverseSearching = false;\n    while (index >= 0) {\n      if (!collection2.getItemDisabled(items[index])) {\n        newValue = collection2.getItemValue(items[index]);\n        break;\n      }\n      if (index < items.length - 1 && !isReverseSearching) {\n        index++;\n      } else {\n        isReverseSearching = true;\n        if (index > (startIndex ?? 0)) {\n          index = startIndex ?? 0;\n        }\n        index--;\n      }\n    }\n    return newValue;\n  }\n  return null;\n}\nvar props = createProps()([\"collection\", \"defaultHighlightedValue\", \"defaultValue\", \"dir\", \"disabled\", \"deselectable\", \"disallowSelectAll\", \"getRootNode\", \"highlightedValue\", \"id\", \"ids\", \"loopFocus\", \"onHighlightChange\", \"onSelect\", \"onValueChange\", \"orientation\", \"scrollToIndexFn\", \"selectionMode\", \"selectOnHighlight\", \"typeahead\", \"value\"]);\nvar splitProps = createSplitProps(props);\nvar itemProps = createProps()([\"item\", \"highlightOnHover\"]);\nvar splitItemProps = createSplitProps(itemProps);\nvar itemGroupProps = createProps()([\"id\"]);\nvar splitItemGroupProps = createSplitProps(itemGroupProps);\nvar itemGroupLabelProps = createProps()([\"htmlFor\"]);\nvar splitItemGroupLabelProps = createSplitProps(itemGroupLabelProps);\nexport { anatomy, collection, connect, gridCollection, itemGroupLabelProps, itemGroupProps, itemProps, machine, props, splitItemGroupLabelProps, splitItemGroupProps, splitItemProps, splitProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}